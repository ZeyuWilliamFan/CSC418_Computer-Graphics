Overall Summary
——————————————————————————————————————————————————————————————————
For Assignment 3, we finished Part 1 fully as required, generating three sets of pictures: SCENE_SIGNATURE, DIFFUSE_AMBIENT, PHONG. While each of set contains two images to view the square and ellipsoid from different view directions. Basically, the idea for part 1 is to implement the scene_object.cpp, to correctly calculate the intersection point of a ray casting onto the square/sphere, and get the attributes on the intersection point such as material, normal vector, etc. By applying the algorithm and techniques introduced in class and from the course website, the PHONG shading is properly generated without much trouble.

For anti_aliasing in part 1, we utilized stratified sampling by treating each pixel of the image as a  n*n grid, while n is the parameter to set for anti-aliasing in the code. The larger n is, the more squares the grid will have, and thus a better anti-aliasing effect. For each square in the grid, we randomly pick a point in the square, and by averaging the color from all squares, we get a final anti-aliased color for the pixel. We found that a 2*2 grid could give the fairly good result.

For Part 2, we chose to implement an advanced ray-tracer, and successfully implemented the following features:
Handling a non-trivial compound object: Cylinder
Glossy reflection, with recursive ray-tracing technique applied to get a “double/triple/etc.. bounce” effect.
Extended light sources, in order to produce soft shadows.
Texture mapping.
Motion Blur


Part 2 Details
——————————————————————————————————————————————————————————————————
The work is even distributed between two of us. Zeyu takes care of the glossy reflection, hard shadow, extended light sources as well as the soft shadow effects. Hao implemented cylinder object, motion blur and texture mapping including a world-mapping sphere and a black/white chessboard.
——————————————————————
Extended light sources and soft shadows:
For this feature, the first thing to do is to generate the hard shadow with a single point light. This was implemented by casting a ray for every original ray, in a direction pointing to the light source. In other words, for every pixel that we can “view”, we want to know if that pixel is in shadow or not, and the best way to solve if is to cast a ray from that pixel to the light source, and if the ray is blocked by any other object (i.e has a t_value between 0.01 and 0.99 ), the pixel then is in shadow.
Knowing the algorithm for a single point light hard shadowing, the extends light and soft shadowing becomes easy to handle. Basically, we utilize a similar technique to anti-aliasing, whereas we sampled n*n point light sources for each defined PointLight to approximate an AreaLight. We added a subclass, AreaLight under LightSource class. The AreaLight is defined by a point and two vectors. By calling the “sampling()” method we can generate a n*n light source, with the given center point for AreaLight. In the computeShading method, n*n rays will be generated from the pixel point, aiming at the AreaLight sources. The shade() method in light_source.cpp then determines whether it to be in shadow, and if it is, color it with the material’s ambient color. When we get n*n such kind of colors, we average them all to produce a soft shadow effect.
——————————————————————
Glossy Reflection:
For glossy reflection, the idea is somewhat related to that of shadowing. The difference is that we no longer generate rays aiming at the light source, instead, for each pixel that we “view”, generate rays aiming at a reflection angle, determined by the view angle and normal. The image we see as the “reflected image” are the objects hit by those reflecting rays.

An interesting thing about our version of reflection is that we added a reflection index, named “glossy” for the material struct. And this index can control how “fuzzy” the reflection on this material is going to be. An index of 0 would give a perfect mirror-effect reflection. Generally, we set this value being 0.2 for reflective materials, which is enough to give reflections, but somewhat fuzzy so it looks realer. The implementation of this fuzzy factor is a bit tricky, an easy way to think about it is, for each reflecting ray, we send multiple of them, as in a “square pyramid” shape. These multiple rays are basically the perfect-reflection ray plus some randomized offset value. And similar to soft shadowing, we recursively call the shadeRay function, and averaging the colors generated by the multiple reflecting rays, we get our final reflection color of a pixel.
 
The “bounce” value determines how many bounces between two reflective object there should be. Generally, a bounce value of 3 or 4 will suffice.
——————————————————————
Texture Mapping:
For the plane, we used a combination of cosine and sine functions to generate different color for each point depending on their position with the respect to the center of the object. Also, use an if-else statement to vary the color between white and black.
For the sphere, we first load the bmp RGB buffer from earth.bmp. During mapping, we convert the sphere coordinates to u,v coordinates varying from 0 to 1. (reference from https://www.siggraph.org/education/materials/HyperGraph/mapping/spheretx.htm
). Then, multiply the width and height of earth.bmp with u and v value to assign the color of each point. 
——————————————————————
Cylinder: We simply follow the idea from the sphere. we first use sphere equation and line equation to get possible intersection points for an infinite unit cylinder aligned along the y-axis and then find possible intersection points for its top and bottom. To know if the ray intersects with top or bottom or side, we use the smallest t_value to define the intersection point and assign normal for it. If the intersection point is at the top, then the normal vector will be (0,1,0) pointing upwards. (bottom, 0,-1,0, downwards). If it is on the side of the cylinder, its normal vector is defined base on it x and z value
——————————————————————
Motion Blur: Motion Blur is implemented by continuously moving the object while rendering. The trick is that the color is influenced by the position of the earth. The color for the first move of the earth will be the lightest. As it keeps moving up, the color appears heavily. It is achieved by using one extra for loop and dividing the color into different proportion. To be more specific, we render the pic 10 times and each time the earth will move up and color will become much heavier. Each time, we divide color by summing 1/n^2 from 1 to 10, which will result in 0.99, close to 1.
——————————————————————
Final Scene:
For the final scene, we basically have every advanced ray tracer features embedded in one image. We put an Earth mapped sphere in the mid air, moving towards a +y direction (i.e motion blurring up). Besides that, we generated 2 spheres and 1 cylinder, all in a same reflective metal material, so that we can see the reflections of these objects. Due to the limited size of the image(since it would be too much of rendering time if we increase the size.) and the sphere, it might be hard to see the secondary reflection on the spherical surfaces. But it is surely there, if looking carefully. The light source of the scene is put at the (top right back) point of the room, and the soft shadows of the Earth sphere can be clearly seen on the left wall.  

To make things interesting, we set the ground to be like a chessboard, so the reflection of the chessboard on the spherical surfaces can be more apparent and the chessboard itself is reflective, as we can see the reflected image of the cylinder and spheres on the ground.

In addition to the FinalScene.bmp, we also add a soft_shadow_fuzzy_reflection.bmp file, which is used to demonstrate the fuzzy_reflection(with recursive bounces) feature and the soft shadows features clearly. Also, we put a static Earth sphere in this scene as the one in Final Scene is motion-blurring so we make a static one for comparing. Note that in this image, the jade colored Cylinder is non-reflective in order to set a contrast with the reflective materials.
——————————————————————
Resources:
Material: http://www.it.hiof.no/~borres/j3d/explain/light/p-materials.html
Texture mapping: https://www.siggraph.org/education/materials/HyperGraph/mapping/spheretx.htm



